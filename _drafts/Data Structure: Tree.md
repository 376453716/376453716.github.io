#### Tree 树

#### Binary tree 二叉树
是每个节点最多只有两个分支的树结构
广度优先遍历：
L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则先(根)序遍历二叉树的顺序是DLR，中(根)序遍历二叉树的顺序是LDR，后(根)序遍历二叉树的顺序是LRD。还有按层遍历二叉树。这些方法的时间复杂度都是O(n)，n为结点个数。
广度优先遍历：队列层级遍历
#### 二叉查找树
查找：若x等于b的根节点的数据域之值，则查找成功；若x小于b的根节点的数据域之值，则搜索左子树；查找右子树。
插入：若s->data等于b的根节点的数据域之值，则返回，否则：若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：把s所指节点插入到右子树中。（新插入节点总是叶子节点）
删除：
构造：
查找性能：最坏情况下，当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树，树的深度为 n，其平均查找长度为  （n+1）/2（和顺序查找相同），最好的情况是二叉查找树的形态和折半查找的判定树相同，其平均查找长度和O(log2(n))。



#### 平衡树
1. 一般的二叉查找树的查询复杂度是跟目标结点到树根的距离（即深度）有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。
1. 几乎所有平衡树的操作都基于树旋转操作，通过旋转操作可以使得树趋于平衡。 对一棵查找树（search tree）进行查询、新增、删除等动作，所花的时间与树的高度h成比例，并不与树的容量 n 成比例。如果可以让树维持矮矮胖胖的好身材，也就是让h维持在O（log n）左右，完成上述工作就很省时间。能够一直维持好身材，不因新增删除而长歪的搜寻树，叫做平衡树（balanced search tree）。


##### AVL树
##### 红黑树
#### B-tree
#### B+tree
#### B*tree
