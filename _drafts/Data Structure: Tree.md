#### Tree 树

#### Binary tree 二叉树
是每个节点最多只有两个分支的树结构
广度优先遍历：
L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则先(根)序遍历二叉树的顺序是DLR，中(根)序遍历二叉树的顺序是LDR，后(根)序遍历二叉树的顺序是LRD。还有按层遍历二叉树。这些方法的时间复杂度都是O(n)，n为结点个数。
广度优先遍历：队列层级遍历
#### 二叉查找树
查找：若x等于b的根节点的数据域之值，则查找成功；若x小于b的根节点的数据域之值，则搜索左子树；查找右子树。
插入：若s->data等于b的根节点的数据域之值，则返回，否则：若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：把s所指节点插入到右子树中。（新插入节点总是叶子节点）
删除：
构造：
查找性能：最坏情况下，当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树，树的深度为 n，其平均查找长度为  （n+1）/2（和顺序查找相同），最好的情况是二叉查找树的形态和折半查找的判定树相同，其平均查找长度和O(log2(n))。



#### 平衡树
1. 一般的二叉查找树的查询复杂度是跟目标结点到树根的距离（即深度）有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。
1. 几乎所有平衡树的操作都基于树旋转操作，通过旋转操作可以使得树趋于平衡。 对一棵查找树（search tree）进行查询、新增、删除等动作，所花的时间与树的高度h成比例，并不与树的容量 n 成比例。如果可以让树维持矮矮胖胖的好身材，也就是让h维持在O（log n）左右，完成上述工作就很省时间。能够一直维持好身材，不因新增删除而长歪的搜寻树，叫做平衡树（balanced search tree）。


##### AVL树
通过选择保证树的平衡
##### 红黑树
1. 二叉平衡查找树
2. 每个节点增加颜色的属性，根据颜色规定节点规则，保证了树的平衡
3. 新加入的节点破坏了规则时，需要通过旋转保证满足规则
#### B-tree
1. 减少树的高度，适用于读取磁盘文件的场景，减少磁盘IO
2. 减少树的高度，增加树的宽度，每个节点可以有多个分支
3. 每个节点关键节点可以包含大量分支信息，（不能超过磁盘快的长度）
#### B+tree
1. 数据都存储在叶子节点，所以内部索引节点可存储更多都索引信息，树都高度更小，查询速度更稳定
2. 增加了兄弟节点指针，叶子节点是一个有序链表，可以快速进行全表扫描
#### B*tree
1. 内部节点超过大小时会分裂，B树直接新增一个节点，空间利用率低
2. B*树从前后两个节点拿出1/3的数据组成新的节点，利用率高，可以减少分裂次数
