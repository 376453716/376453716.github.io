### 分布式事务常用解决方案

#### 事务
- ACID
  - A 原子性:不可分割，必须全部执行或全部回滚
  - C 一致性:事务满足一致性约束条件，数据库完整性约束条件不被破坏（例如：外键约束，主表插入了一个外键表不存在的值则不一致）
  - I 隔离性:多个事务并行时互不影响
  - D 持久性:事务结果是持久的
- 隔离级别
  - 读未提交：脏读，可能读到事务未提交的数据
  - 读已提交：避免脏读；不可重复读->事务1第一次读到A，此时事务2修改了A的值并提交了事务，事务1再次读取A时读到已提交的A，两次读取的值不一致
  - 可重复读：幻读->只对已有记录进行了锁定，事务A读取结果集，然后事务2插入了新的记录，再次读取会读到新插入的记录，两次读取的值不一致
  - 串行化:

#### 本地事务
由资源管理器实现

#### 全局事务
DTP：AP应用
RM资源管理器：控制管理资源
TM事务管理器：管理事务生命周期，协调资源
TX协议：应用于事务管理器的接口
XA协议：事务管理器与资源管理器接口


#### 两阶段提交
> 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。

1. 前提：
    - 一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。节点之间可以进行网络通信。
    - 所有节点采用预写式日志
    - 所有节点不会永久性损坏
2. 步骤：
    1. 第一阶段(Prepare)
    - 协调者询问参与者，执行预提交
    - 参与者执行预提交，写(redo/undo)日志
    - 根据各节点响应结果，决定是否进行第二阶段提交
    2. 第二阶段(commit)
    - 成功：当协调者节点从所有参与者节点获得的相应消息都为"同意"时：
        - 协调者发起正式提交请求
        - 参与者节点正式完成操作，释放事务占用的资源
        - 想协调者节点发送完成消息
        - 协调者节点收到参与者的'完成'消息，完成事务
    - 失败：如果任一参与者节点在第一阶段返回的响应消息为"终止"，或者超时无法获取所有参与者节点的响应消息时：
        - 协调者向参与者发起'回滚'请求
        - 参与者利用undo信息执行回滚，释放事务占用的资源
        - 参与者发送'回滚完成'消息
        - 协调者收到参与者'回滚完成'消息，取消事务
3. 缺点
    - 同步柱塞：执行中节点处于阻塞状态，会让所有参与者都在等待，代价大,业务规模越大，伸缩性差，Lock时间长，开销大，伸缩性低
    - 单点故障：协调者发生故障，无法继续完成事务操作
    - 不一致: 部分参与者收到commit请求的情况
    - 问题： 协调者发出commit后故障，唯一收到消息的参与者也故障，则事务状态无法确定

### 三阶段提交
CanCommit PreCommit DoCommit

#### BASE
basic available：基本可以，分区失败
soft state：允许短时间不同步
eventual consistency：最终一致性


#### CAP
一致性，可用性，分区容忍性
绝大多数情况尽可能保证CAP，当发生网络分区时，进入分区模式，限制某些系统操作，恢复后能够弥补数据的一致性


#### 可靠消息最终一致性
1. 业务处理服务在业务事务提交前，向实时消息服务请求发送消息，实时消息服务只记
录消息数据，而不真正发送。业务处理服务在业务事务提交后，向实时消息服务确认
发送。只有在得到确认发送指令后，实时消息服务才真正发送。

2. 业务处理服务在业务事务回滚后，向实时消息服务取消发送。消息状态确认系统定期
找到未确认发送或回滚发送的消息，向业务处理服务询问消息状态，业务处理服务根
据消息ID或消息内容确定该消息是否有效

3. 约束，被动方执行结果不影响发起方，被动方幂等处理

4. 成本：一次消息发送需要两次请求，业务处理服务需实现消息状态回查

5. 消息数据独立存储、独立伸缩，降低业务系统与消息系统间的耦合，对最终一致性时间敏感度较高，降低业务被动方实现成本


#### TCC


#### 最大努力通知型
1. 发起方通过消息通知
2. 接收方定时通过接口恢复丢失的消息
