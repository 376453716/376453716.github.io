---
layout:     post
title:      java辣鸡回收
subtitle:   
date:       2018-06-11
author:     Hao
catalog: true
tags:
    - 事务,分布式
---
#### jvm内存区域
1. 程序计数器：每个线程的执行字节码指令
2. java虚拟机栈：每个java方法创建的栈帧
3. 本地方法栈：JNI
4. 堆：线程共享的内存
5. 方法区：类信息，常量，静态变量，及时编译的代码

### 垃圾收集

#### 垃圾对象
1. 引用计数法
  - 实现：引用对象时，添加对象应用计数器
  - 问题：循环引用
2. 可达性分析
  1. GC Root：从root节点查找，引用链，对象到root没有引用链则不可达
  2. root：
    - 虚拟机栈中的对象
    - 方法去中静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈引用的对象
3. 引用
  - 强引用：存在引用时不会被回收
  - 软引用：内存溢出前会进行二次回收
  - 弱引用：下一次GC会被回收
  - 虚引用：不会影响GC
4. 方法区回收：
  1. 常量回收：没有被引用
  2. 类卸载：没有实例，classloader被回收，Class对象无引用，无法反射创建类

#### 收集算法
##### 标记清除
遍历所有对象，标记需要清理的对象，
- 标记和清除效率低
- 内存碎片
##### 复制算法
1. 将内存分为eden和两个survivor，每次使用eden和其中一个survivor，
2. 回收的时候讲还存活的对象复制到另一survivor
3. 清除掉eden和survivor空间
4. 如果survivor区域不足则直接进入老年代
5. 如果对象存活率高则复制效率低，所以适用于新生代
##### 标记-整理
1. 让存活的对象移动到内存区域的一段，然后清除存活边界外的区域
2. 适用于老年代，存活率高的对象
##### 分代收集
1.根据对象存活的特点分为不同的区域，每个区域选择合适的算法

#### jvm垃圾收集器
1. serial/parnew->[cms]->serial old
2. Parallel Scavenge->[parallel Old]->serial old(MSC)
3. G1

- 并发：垃圾收集器可多线程执行收集
- 并行：垃圾收集线程与用户线程同时执行

##### serial
1. 新生代单线程收集器，复制算法
1. 单线程收集器，必须暂停其他所有工作线程
2. 简单高效，单核的情况下，没有线程交互切换的开销
3. 适用于桌面场景，需回收的内存小，所有停顿时间低，可以接受
##### ParNew
1. 多线程版本的serial，可以利用多个CPU
2. 单CUP的情况下不会比serial效率高
##### Parallel Scabenge
1. 目的是提高吞吐量，减小总的垃圾收集时间，而不是减小垃圾收集停顿的时间（用户运行代码的时间/代码时间+垃圾收集时间）
2. 高吞吐量可高效利用CPU，适合后台运算的任务
3. 如果缩短gc时间，则会把新生代空间降低，使得每次gc的时间段，但gc更频繁，导致吞吐量下降（如 10秒一次gc暂停100ms->5秒一次，暂停70ms）
4. 可设置动态调整由虚拟机决定最合适的停顿时间
##### Serial Old
1. 标记-整理算法
2. 老年代单线程收集器
3. 客户端模式下使用
##### Parallel Old
1. Parallel Scabenge老年代版本
##### CMS
1.步骤：
  - 标记清除算法
  - 初始标记：stop world，标记GCroot能关联的对象，速度很快
  - 并发标记：耗时长，可并行执行
  - 重新标记：stop world，修正并发标记期间发生变动的对象，耗时短
  - 并发清除：耗时长，可并行执行
2. 并发阶段会占用cpu资源，导致吞吐量降低，如cpu核心少时，还需分配单独的cpu执行收集线程
3. 浮动垃圾：CMS执行时，系统运行还会产生垃圾，需要预留空间给用户线程使用
  - 可通过参数设置激活CMS的大小，1.6超过92%会激活cms
  - CMS运行期间如果内存不足，会导致Concurrent Mode Failure，启用Serial Old重新收集，导致停顿时间长
4. 内存碎片：
  - 内存碎片空间足够，但当需要连续空间时
  - 默认开启在CMS空间不足进行full gc时整理碎片 ，内存整理无法并行导致停顿增长
  - 可设置执行执行一定次数后，进行一次带压缩的full GC
##### G1
1. 实现：
  - 将内存划分为多个独立的区域，新生代老年代都是一组region的集合
  - 可以有计划的避免进行全区域的垃圾收集
  - 跟踪各个region的垃圾堆积大小，维护优先列表，优先回收价值大的region，保证在有限的时间尽可能的提高收集效率

1. 难点：
  - 一个对象可能被多个其他region中的对象引用，如新生代被老年代对象引用
  - 如果新生代回收时需要扫描老年代则效率会下降
  - 通过remembered Set避免全堆扫描
  - 对Reference对象进行写操作时，会检查是否处于不同的region中，是则通过cardTable记录到所属的remembered Set中

1. 特点
  - 并发与并行
  - 分带收集
  - 空间整合
  - 停顿时间低

1. 过程
  - 初始标记：短停顿
  - 并发标记：并行
  - 最终标记：短停顿，记录到remembered set log中，最后合并到remembered set
  - 筛选回收：并行

#### GC log

#### 分配策略
1. 对象优先分配在eden
  - eden不足时，发起minor gc
2. 大对象直接进入老年代
  - 避免大对象复制
  - MajorGc /full gc
3. 长期存活对象进入老年代，可设置存活次数

### 性能监控与故障处理
1. 命令
  - jps:查看进程情况
  - jstat：查看类装载、垃圾收集、JIT信息
  - jmap：查看内存信息，dump
  - jhat：快照转存
  - jstack：堆栈跟踪，查看现场执行堆栈
2. 工具
  - jconsole
  - visual vm

#### 调优实战
1. full gc
  - 控制full gc 频率，如每天深夜执行
  - 查看是否大多数对象生存时间不长，不能有成批量的长时间生存的大对象产生，保证老年代空间稳定
2. cpu占用高
  - top命令找出有问题Java进程及线程id：
  - 开启线程显示模式（top -H，或是打开top后按H）
  - 按CPU使用率排序（top缺省是按CPU使用降序，已经合要求；打开top后按P可以显式指定按CPU使用降序）
  - 记下Java进程id及其CPU高的线程id
  - 用进程id作为参数，jstack有问题的Java进程
  - 手动转换线程id成十六进制（可以用printf %x 1234）
  - 查找十六进制的线程id（可以用vim的查找功能/0x1234，或是grep 0x1234 -A 20）
  - 查看对应的线程栈，以分析问题

