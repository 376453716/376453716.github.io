---
layout:     post
title:      JVM笔记
subtitle:   
date:       2017-06-08
author:     Hao
catalog: true
tags:
    - jvm
---
#### jvm内存区域
1. 程序计数器：每个线程的执行字节码指令
2. java虚拟机栈：每个java方法创建的栈帧
3. 本地方法栈：JNI
4. 堆：线程共享的内存
5. 方法区：类信息，常量，静态变量，及时编译的代码

### 垃圾收集

#### 垃圾对象
1. 引用计数法
  - 实现：引用对象时，添加对象应用计数器
  - 问题：循环引用
2. 可达性分析
  1. GC Root：从root节点查找，引用链，对象到root没有引用链则不可达
  2. root：
    - 虚拟机栈中的对象
    - 方法去中静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈引用的对象
3. 引用
  - 强引用：存在引用时不会被回收
  - 软引用：内存溢出前会进行二次回收
  - 弱引用：下一次GC会被回收
  - 虚引用：不会影响GC
4. 方法区回收：
  1. 常量回收：没有被引用
  2. 类卸载：没有实例，classloader被回收，Class对象无引用，无法反射创建类

#### 收集算法
##### 标记清除
遍历所有对象，标记需要清理的对象，
- 标记和清除效率低
- 内存碎片

##### 复制算法
1. 将内存分为eden和两个survivor，每次使用eden和其中一个survivor，
2. 回收的时候讲还存活的对象复制到另一survivor
3. 清除掉eden和survivor空间
4. 如果survivor区域不足则直接进入老年代
5. 如果对象存活率高则复制效率低，所以适用于新生代

##### 标记-整理
1. 让存活的对象移动到内存区域的一段，然后清除存活边界外的区域
2. 适用于老年代，存活率高的对象

##### 分代收集
1.根据对象存活的特点分为不同的区域，每个区域选择合适的算法

#### jvm垃圾收集器
1. serial/parnew->[cms]->serial old
2. Parallel Scavenge->[parallel Old]->serial old(MSC)
3. G1

- 并发：垃圾收集器可多线程执行收集
- 并行：垃圾收集线程与用户线程同时执行

##### serial
1. 新生代单线程收集器，复制算法
1. 单线程收集器，必须暂停其他所有工作线程
2. 简单高效，单核的情况下，没有线程交互切换的开销
3. 适用于桌面场景，需回收的内存小，所有停顿时间低，可以接受

##### ParNew
1. 多线程版本的serial，可以利用多个CPU
2. 单CUP的情况下不会比serial效率高

##### Parallel Scabenge
1. 目的是提高吞吐量，减小总的垃圾收集时间，而不是减小垃圾收集停顿的时间（用户运行代码的时间/代码时间+垃圾收集时间）
2. 高吞吐量可高效利用CPU，适合后台运算的任务
3. 如果缩短gc时间，则会把新生代空间降低，使得每次gc的时间段，但gc更频繁，导致吞吐量下降（如 10秒一次gc暂停100ms->5秒一次，暂停70ms）
4. 可设置动态调整由虚拟机决定最合适的停顿时间

##### Serial Old
1. 标记-整理算法
2. 老年代单线程收集器
3. 客户端模式下使用

##### Parallel Old
1. Parallel Scabenge老年代版本

##### CMS
1. 步骤：
  - 标记清除算法
  - 初始标记：stop world，标记GCroot能关联的对象，速度很快
  - 并发标记：耗时长，可并行执行
  - 重新标记：stop world，修正并发标记期间发生变动的对象，耗时短
  - 并发清除：耗时长，可并行执行
2. 并发阶段会占用cpu资源，导致吞吐量降低，如cpu核心少时，还需分配单独的cpu执行收集线程
3. 浮动垃圾：CMS执行时，系统运行还会产生垃圾，需要预留空间给用户线程使用
  - 可通过参数设置激活CMS的大小，1.6超过92%会激活cms
  - CMS运行期间如果内存不足，会导致Concurrent Mode Failure，启用Serial Old重新收集，导致停顿时间长
4. 内存碎片：
  - 内存碎片空间足够，但当需要连续空间时
  - 默认开启在CMS空间不足进行full gc时整理碎片 ，内存整理无法并行导致停顿增长
  - 可设置执行执行一定次数后，进行一次带压缩的full GC

##### G1
1. 实现：
  - 将内存划分为多个独立的区域，新生代老年代都是一组region的集合
  - 可以有计划的避免进行全区域的垃圾收集
  - 跟踪各个region的垃圾堆积大小，维护优先列表，优先回收价值大的region，保证在有限的时间尽可能的提高收集效率

1. 难点：
  - 一个对象可能被多个其他region中的对象引用，如新生代被老年代对象引用
  - 如果新生代回收时需要扫描老年代则效率会下降
  - 通过remembered Set避免全堆扫描
  - 对Reference对象进行写操作时，会检查是否处于不同的region中，是则通过cardTable记录到所属的remembered Set中

1. 特点
  - 并发与并行
  - 分带收集
  - 空间整合
  - 停顿时间低

1. 过程
  - 初始标记：短停顿
  - 并发标记：并行
  - 最终标记：短停顿，记录到remembered set log中，最后合并到remembered set
  - 筛选回收：并行

#### GC log

#### 分配策略
1. 对象优先分配在eden
  - eden不足时，发起minor gc
2. 大对象直接进入老年代
  - 避免大对象复制
  - MajorGc /full gc
3. 长期存活对象进入老年代，可设置存活次数

### 性能监控与故障处理
1. 命令
  - jps:查看进程情况
  - jstat：查看类装载、垃圾收集、JIT信息
  - jmap：查看内存信息，dump
  - jhat：快照转存
  - jstack：堆栈跟踪，查看现场执行堆栈
2. 工具
  - jconsole
  - visual vm

#### 调优实战
1. full gc
  - 控制full gc 频率，如每天深夜执行
  - 查看是否大多数对象生存时间不长，不能有成批量的长时间生存的大对象产生，保证老年代空间稳定
2. cpu占用高
  - top命令找出有问题Java进程及线程id：
  - 开启线程显示模式（top -H，或是打开top后按H）
  - 按CPU使用率排序（top缺省是按CPU使用降序，已经合要求；打开top后按P可以显式指定按CPU使用降序）
  - 记下Java进程id及其CPU高的线程id
  - 用进程id作为参数，jstack有问题的Java进程
  - 手动转换线程id成十六进制（可以用printf %x 1234）
  - 查找十六进制的线程id（可以用vim的查找功能/0x1234，或是grep 0x1234 -A 20）
  - 查看对应的线程栈，以分析问题


#### class 文件结构


#### 类加载机制
1. 加载场景；
  - 使用new创建对象
  - 读取或设置静态字段
  - 调用静态方法
  - 类反射调用
  - 子类初始化时触发父类初始化
  -
1. 加载过程：
  - 加载：
    - 获取类的二进制字节流：classPath、jar、war、网络
    - 转化为方法区的运行时数据结构
    - 创建Class对象
  - 验证：
    - 格式验证、版本号验证等
    - 元数据验证：符合语言规范
    - 字节码验证： 方法体
    - 符号引用验证：字段、方法是否存在，privte访问权限等
  - 准备：分配内存设置初始值
  - 解析：
    - 符号引用、直接引用解析
    - 类、接口解析
    - 字段解析
    - 方法解析
  - 初始化：
    - 虚拟机保证init线程安全
2. 类加载器
  - 类加载器与类本身确定唯一性
  - 双亲委派：先委托给父类加载器加载
    - 启动类加载器
    - 扩展类加载器
    - 应用程序类加载器
3. 实例：tomcat类加载器
  - 场景：
    - 同一个通其中的多个应用相互隔离
    - java类库可以共享
    - jsp热部署
  - 多个类加载器
    - Common：公用
    - catalina：tomcat
    - shared：web应用共享
    - webApp：每个web应用对应一个
    - Jsp：每个jsp文件对应一个，文件修改时通过新建一个jsp类加载器替换实现HotSwap
4. 动态代理
  - 根据Class文件格式动态生成字节码
  - 可以在原始类与接口未知时确定代理类的行为

#### java内存模型
1. 目的：屏蔽硬件与操作系统的内存访问差异，在各平台能有一致的内存访问效果
1. 所有变量都存储在内存中，每个线程在自己的工作内存中保存内存变量的副本，线程变量的传递通过主内存完成。
1. read：将变量从主内存传送到工作内存，load：将变量放入工作内存的变量副本中；store：将工作内存变量值传送到主内存，write，将变量值写入主内存变量中

##### volatile
1. 作用：
  - 保证变量对线程的可见性
  - 禁止指令重排序优化
2. 实现：
  - cup总线lock，通过内存屏障保证一致性，工作线程每次修改变量后都会写入到主内存，实现可见性
  - cpu缓存lock
3. 非线程安全
4. happens-before原则
  - a操作先发送，则b操作可以观测到a的影响，如修改共享变量
  - 同一个锁的释放 before下一次加锁
  - 线程start先于线程的后续操作
  - volatile的写操作先与后面对它的读操作
4. 线程：
  - 基于操作系统的原生线程模型实现
  - 使用抢占时调度，又系统分配执行时间
  - 线程状态：
    - new
    - run
    - wait: sleep,wait，等待唤醒
    - block: 等待锁
    - termicate

#### 锁优化
1. 偏向锁
  - 在无竞争的情况下消除同步，
  - 线程第一次获取到锁之后，虚拟机将对象头标记位设置为偏向模式，同时把线程id记录在锁对象的mard word中，持有偏向锁后每次都不用再同步
  - 可以提高带有同步但无竞争的程序性能
2. 自旋锁
  - 遇到并发请求时，让获取锁的线程执行忙循环
  - 避免线程切换的开销
  - 适用于锁持续时间短的情况，如果时间长则会浪费处理器时间，可以设置自选次数
3. 轻量级锁
  - 在没有锁竞争的情况下，使用cas操作获取锁，减低使用互斥锁的性能消耗
  - 线程中建立一个lock record的空间存储锁对象的mark word，使用cas操作尝试将锁对象的mard word更新为指向当前线程lock record的指针，成功则处于轻量级锁定
  - 适用于不存在锁竞争的情况，如果有锁竞争则除了互斥锁的开销，还多了cas的额外消耗
4. 锁消除与锁升级
