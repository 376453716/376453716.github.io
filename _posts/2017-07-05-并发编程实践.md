## 简介
#### 多线程的优势
1. 发挥多处理器的能力，提高资源利用率
2. 简化异步事件处理
3. GUI用户界面响应

#### 风险
1. 安全性问题（竞状条件）
2. 活跃性问题（死锁）
3. 性能问题（线程调度开销，同步）

## 线程安全性
在多线程访问对象时，不需要进行同步，始终表现出正确的行为

##### 原子性

不可分割的操作，

1. 竞态条件：
> 正确性取决于多个线程交替执行时序时，如“检查然后执行”，通过一个可能失效的结果来决定下一步操作.
事实上，观测结束后到开始执行之间，观测结果可能变为无效（单例模式）.

2. 复合操作：
一组需以原子方式执行的操作

##### 加锁机制
synchronized：内置锁，每次只能一个线程执行，保证原子性
重入：线程试图获取已经持有的锁，（锁关联线程，和锁计数器）
保证独占访问
对于包含多个变量的不变性条件，所有变量都需要同一个锁保护
执行耗时操作时，避免持有锁（网络/IO）

## 对象的共享
#### 可见性
> 一个线程对对象状态修改后，其他线程能看到发生的状态变化

1. 失效值：获取一个对象时，某些变量可能是最新修改的值，某些变量可能是失效的旧值
2. 非原子的64位操作，两个32位操作，高低位的值不一致
3. 加锁保证可见性

volatile： 该变量的操作不会重排序，不会缓存，读取volatile变量时总是会返回最新写入的值，保证可见性，不能保证原子性（count++）

##### 发布与逸出
发布：对象能够在当前作用于以外的代码证使用
逸出：不应该发布时被发布
不要在构造函数中使tihs逸出

##### 线程封闭
1. 不共享数据
2. 站封闭，局部变量不逸出
3。 ThreadLocal

#### 不变性
1. 不可变对象线程安全：
创建后状态不能修改，所有域都是final类型，正确创建（this没有逸出）
2. final域

#### 安全发布
1. 正确的对象被破坏，构造函数未初始化完成
- 静态初始化函数中初始化
- final域
- volatile、AtomicReferance
- 锁保护

#### 安全共享对象
- 线程封闭
- 只读共享，多个线程读，不能修改
- 线程安全共享，内部实现同步
- 锁保护对象

## 对象的组合

## 基础构建模块

#### 同步容器类
1. Vectory：getlast、deleteLast并发，indexOutOfBound
2. 迭代器、ConcurrentModificationException
3。 toString、hashCode、equalse、contain、remove、addAll间接迭代操作

#### 并发容器
1。copyOnWriteArrayList、
2. ConcurrenthashMap
3. ConcurrentlinkedQuene
4. Deque 双端队列、工作窃取

#### 阻塞与中断

#### 同步工具类
1. 闭锁Latch：CountDownLatch 延迟线程进度直到终止状态
2. 信号量Semaphore：控制同时访问某个资源的操作数量
3. Barrier：栅栏 阻塞一组线程直到某个事件发生
4.FutureTask

## 任务执行

####
#### 串行执行
#### 显示创建线程执行任务
1. 创建线程的开销
2. 线程超过cpu数，空闲线程过多，消耗资源
3. 稳定性，系统线程数量限制

#### Executor
1.线程池：避免每次重新创建线程的开销，提高响应性，可设置合理的并发数，使处理器保持忙碌并避免过多的线程竞争资源
2. 生命周期：运行、关闭、已终止
3. 关闭线程池：shutdown 平滑关闭（不接受新任务，等待提交任务执行完成），shutdownNow立即关闭（尝试取消运行中的任务，不再启动未开始的任务）
4. 定时任务： Timer，单线程，任务超时会影响调用周期精确性，任务异常无法恢复
5. Callable：返回值
6. Future： 提供方法判断线程状态，get 未完成时阻塞 取消时抛出CancelException，
7. CompletionService：提交一组任务，包装为队列，将结果放入阻塞队列中，CompletionService.get()委托给队列，阻塞直到得到结果
8. 任务时限： get设置超时时间，invokeAll，设置一组任务的超时时间

## 取消与关闭
#### 取消任务
1. 设置取消标志
2. 中断：不会中断运行的线程，只是发出中断请求，阻塞方法库会检查线程是否中断，并相应中断，提前返回。
显示的判断中断状态，能起到一定的作用提高响应性
3. Future.cancel()
4.线程异常处理：主动try-cache，线程池指定UncaughtExceptionHandler

#### JVM关闭
1. showdown hook
2. 守护线程
3. finalize

## 线程池
1. 单线程池饥饿死锁
2.运行时间较长的任务，堵塞线程池，影响响应性：限定任务等待资源的时间

#### 线程池大小
计算密集型：cup+1
估算任务的等待时间与计算时间的比值
资源总量/每个任务需要的资源=线程池大小上限


#### ThreadExecutors
1. 基本线程数，最大线程数，存活时间
2. 任务管理队列：有界队列、无界队列（请求速率超过处理速率，可能资源耗尽）

#### 饱和策略
1. 终止：抛出Reject异常
2. Discard抛弃任务
3. Discard-Oldest：抛弃最旧的（优先队列会导致抛弃优先级最高的，避免混用）
4. 调用者运行： 由提交任务的线程执行，在执行期间无法提交新任务，使工作线程可以由时间处理队列中的任务，实现平缓的性能降低

#### 扩展ThreadPoolExecutor
实现beforeExecute、afterExecute、terminated扩展线程池的行为，实现日子、计时、监控或收集统计信息的功能

## GUI异步
1. 耗时操作放到异步线程中执行，提高UI线程响应性
2. 取消操作，通过Future中断，变形的任务需要能够检查中断的情况，及时响应中断

## 避免活跃性
#### 死锁
1. 数据库死锁：数据库系统会选择一个事务为牺牲者，释放占用的资源
2. java线程死锁：线程无法继续使用，只用终止重启才能恢复

#### 锁顺序死锁
1. 两个线程试图以不同的顺序来获取相同的锁：T1-->a-->b T2-->b-->a
2. 动态的锁顺序死锁：
```
transfer(accountFrom，accountTo): transfer(a,b) transfer(b,a)
```
定义锁的顺序，对对象进行排序
3. 协作对象之间发生死锁：A对象在持有锁时调用外部B对象的方法，会出现活跃性问题，外部方法需要其他锁时可能导致死锁，外部方法耗时过长时，会导致其他线程阻塞等待当前持有的锁
4. 开放调用： 调用某个方法时，不需要持有锁
5. 资源死锁：多个线程相互等待其他线程占用的资源
6. 线程饥饿死锁

#### 死锁避免
1. 确保程序中获取锁的顺序保持一致
2. 获取锁时设置超时时限
3. 死锁分析：thread dump，查看哪些获得锁的情况，阻塞等待锁的情况，死锁信息

#### 其他活跃性危险
1. 饥饿： 线程无法获取所需的资源导致不能被执行到：
- 如线程优先级导致cpu调度不到，避免使用线程优先级
- 无线循环、无线等待某个资源
2.活锁：线程不断的执行重复的操作，无法完成任务
- 错误恢复重试机制，发生错误时，重新处理，然后又发生错误（案例：消息消费失败重试，导致活锁）
- 相互协作的多个线程彼此响应修改各自的状态，（两人让路，一直都给对方让路，导致一直重复）
- 在重试机制中引入随机性

## 性能与可伸缩
1. 多线程提高资源利用率
2. 线程引入的额外性能开销：线程之间的协调(锁，信号，内存同步)、上下文切换、线程的创建销毁、线程调度

#### 性能：
1. 运行速度：响应时间、等待时间。处理任务单元需要多块的时间
2. 处理能力：吞吐量。在一定资源的情况下，能完成多少工作量
3. 伸缩性： 增加资源时，处理能力相应的提升


找出任务中串行的部分：比较当增加线程时候吞吐量当变化，

#### 线程引入当开销
1.上下文切换
- 缓存失效
- 调度开销
- vmstat内核占用率：超过10%表示调度活动发生很频繁
2.内存同步
- 内存栅栏，刷新缓存，抑制编译器当优化，大多数操作不能被重paixu
- 同步增加共享内存总线上当通信量
3. 阻塞
- 自旋等待：
- 操作系统挂起：
- 效率取决于：上下文切换的开销，成功获取锁的等待时间，较短适合自旋

#### 减少锁的竞争
- 减少锁的请求频率，每次持有锁的时间：
  - 降低发生竞争的可能性，缩小锁的范围
  - 降低线程请求锁的频率：锁分解，锁分段（获取多个锁来实现独占访问将更加困难并且开销更高）
  - 避免热点域：ConcurrentHashMap 共享计数器，size缓存，维护每个分段单独的计数器
- 使用带有协调机制的独占锁
  - 并发容器
  - 读写锁
  - 不可变对象
  - 原子变量

#### 监测CUP的利用率
CPU利用不充分：负载不足，I/O密集，外部限制（数据库/接口），锁竞争

#### 减少上下文切换的开销
- 请求服务的时间不应该过长，避免越多的锁竞争
- 将I/O操作从处理请求的线程中分离出来，缩短处理请求的平均时间，

## 并发程序的测试
安全性测试/活跃性测试
阻塞操作的测试



## 显示锁
与内置锁在加锁和内存上提供相同的语艺
#### Lock ReentrantLock 互斥锁
1. 可定时或轮询的获取锁，内置锁很难实现带有时间限制的操作
2. 可中断的锁：lockInterruptibly，保持对中断的响应性
3. 非结构快的加锁，更灵活的加锁规则
4. 公平性

#### 公平性
公平锁：
- 按照发出请求的顺序来获取锁
- 在挂起线程和恢复线程时的开销极大的降低性能；恢复被挂起线程到开始运行之间存在延迟，此时C也请求锁，能获得锁并及时释放

#### 读-写锁
1. 大多数操作都是读操作，可放宽加锁的需求
2. 每个资源可以被多个读操作访问，或者被一个写操作访问
3. 读-写锁复杂性更高，比独占锁性能差一些
4. 可选设置：释放优先，读线程插队，重入性，降级（写锁不释放获取读锁），升级（读锁升级为写锁）

## 构建自定义同步工具
忙等待：休眠，响应性低
自旋：CPU时钟周期浪费

####条件队列
1. 条件谓词： 
- 使某个操作成为状态依赖操作的前提条件，找出对象在哪个条件谓词上等待
- 在测试条件谓词前必须先持有这个锁，锁对象与条件对象必须是同一个对象
- wait() 释放锁，阻塞当前线程，等待知道超时，被中断或通过通知被唤醒，唤醒后需要重新正常的竞争获取锁，
2. 过早唤醒：多个条件复用，唤醒时，可能条件谓词并没变成真，
- 唤醒后需要再次测试条件谓词
3. 丢失的信号
- 通知：notify(),notifyAll(),发出通知时需要持有锁
- 发出通知后应该尽快释放锁
- 大多数情况优先旋转notifyAll()
- notify()：所有等待线程类型相同，单进单出

#### 显示Condition对象
1. 内置队列缺陷
  - 每个内置锁只能有一个相关联的条件队列
  - 多个线程可能在同一个条件队列上等待不同的条件谓词
2. Condition
  - 多个等待，可中断，可基于实现的等待
  - 每个Lock可以有任意数量的Condition，继承来Lock的公平性
  - await(),signal(),signalAll()

#### AbstractQueueSynchronizer
1. 管理Integer类型的状态信息
2. 基于AQS的同步器类
  - ReentrantLock：compareAndSetState原子地更新状态
  - Semaphore/CountDownLatch：同步状态保存当前可用的许可数量
  - FutureTask： get() AQS保存任务的状态：运行/已完成/已取消
  - ReentrantReadWriteLock： 写入锁/读取锁计数器，等待线程队列

## 原子变量与非阻塞同步机制
非阻塞算法：通过底层的原子机器指令（CAS）代替锁来确保数据在并发访问中的一致性

#### 锁的劣势
1. 挂起和恢复过程有很大开销
2. 持有锁的线程延迟执行时(缺页错误。调度延迟)所有需要锁的线程都无法执行
3. 可能导致优先级高的线程被优先级低的线程阻塞（优先级反转）

#### 硬件对并发的支持
1. 独占锁：悲观；乐观方法：借助冲突检查机制判断在更新过程中是否存在来自其他线程的干扰
2. 比较并交换(CAS)
  - 非阻塞
  - 由调用者处理竞争问题（重试，回退，放弃）

#### 原子变量类
比锁粒度更细，更轻量级，更好的volatile
- 标量类
- 更新器类
- 数组类
- 复合变量类

#### 非阻塞算法
找出将原子修改的范围缩小到单个变量上，维护数据一致性

#### ABA
更新对象-版本号

## 内存模型
#### 平台内存模型
1. 多处理器体系中，每个处理器有自己的缓存
2. 每个处理器不必要知道其他处理器正进行的工作，放宽一致性
3. 通过特殊指令（内存栅栏）实现额外的存储协调保证
4. jvm通过内存栅栏屏蔽JMM与底层平台内存模型的差异

#### 重排序

#### java 内存模型
1. Happens-Before

#### 双重检查锁定
1. 在没有同步的情况下读取一个共享变量时可能读取到无效值（未初始化完成），通过volatile启用DLC
2. 通过静态内部类延迟初始化占位模式：JVM初始化期间将获得锁，内存写操作自动对所有线程可见，不需要显示的同步

